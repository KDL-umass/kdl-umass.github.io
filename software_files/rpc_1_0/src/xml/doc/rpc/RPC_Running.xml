<?xml version="1.0" encoding="UTF-8"?>

<!-- Part of the open source KDL Relational PC package (see LICENSE for
     copyright and license information).
-->

<chapter id="ch_running">
<title>Running Relational PC</title>

<!-- ============================================================== -->
<!--                       SCRIPTING OVERVIEW                       -->
<!-- ============================================================== -->

<section>
<title>Scripting Overview</title>

<para>&rpc; is run via Jython scripts.  Using Jython permits access to
the full &rpc; Java class library. Source code files for the scripts
discussed in this section are available in 
<filename>&rpcexamplespath;</filename>.</para>

<!-- .............................................................. -->
<!--                    Importing Proximity packages                -->
<!-- .............................................................. -->

<section>
<title>Importing &rpc; packages</title>

<para>You only need to import a class or package when you
refer to a class by name, such as when instantiating a class
object, using a static method, or referring to one of its class
variables.</para>

</section>

<!-- .............................................................. -->
<!--                          Executing scripts                     -->
<!-- .............................................................. -->

<section>
<title>Executing scripts</title>

<para>To execute an &rpc; script, call <filename>&rpchome;/bin/script.sh</filename>
from a terminal window, passing the required arguments on the command line.  You must provide
the name of the Jython script; other aruments are optional and depend
on the requirements of your Jython script.</para>

<para>To execute the example scripts included in this release, use
<synopsis>&prompt; <userinput>&rpchome;/bin/script.sh <replaceable>script-file</replaceable> <replaceable>db-name</replaceable> <replaceable>schema-file</replaceable></userinput>
</synopsis>
where
<itemizedlist>
<listitem>
<para><replaceable>db-name</replaceable> is the name of the database, and</para>
</listitem>

<listitem><para><replaceable>script-file</replaceable> and
<replaceable>schema-file</replaceable> must be relative paths within
the &rpc; installation tree or fully qualified paths
to the corresponding files.</para></listitem>
</itemizedlist>
</para>

</section>

<!-- .............................................................. -->
<!--                        Controlling logging                     -->
<!-- .............................................................. -->

<section>
<title>Controlling logging</title>

<para>The &rpcpkg; uses 
<ulink url="http://logging.apache.org/log4j/"><application>log4j</application></ulink>
to control the level of logging information displayed.  
To control the logging options, &rpc; looks for a configuration file named
<filename>rcp.lcf</filename> in the directory from which you execute
the <filename>script.sh</filename> command.
The default set up of &rpc; provides no logging configuration file and logs only
the major milestones and output of the algorithm.</para>

<para>You can include additional details in the logging trace by
specifying a configuration file for <application>log4j</application>.
An example configuration file that provides detailed traces of the
algorithm&rsquo;s actions, including queries and statistical tests, is included in
<filename>&rpchome;/example/config/rcp.lcf</filename>.  
Copy the example configuration file to <filename>&rpchome;</filename>
to use its settings.  Or create a new configuration file, name it
<filename>rcp.lcf</filename>, and place it in
<filename>&rpchome;</filename> to define your own logging options.</para>

</section>

</section>

<!-- ============================================================== -->
<!--                    RUNNING RPC ON GENERATED DATA               -->
<!-- ============================================================== -->

<section  id="datagenrun">
<title>Running &rpc; on Generated Data</title>

<para>The <filename>runRPC.py</filename> script illustrates how to run
&rpc; on generated data. The generated data used in this example is
described by the schema file 
<filename>&rpchome;/example/schemas/datagen-schema.pl</filename>.
This schema file is discussed in detail in
<xref linkend="ch_data"/>, later in this document.</para>

<!-- .............................................................. -->
<!--                     Code Example: runRPC.py                    -->
<!-- .............................................................. -->

<para>Import needed classes.</para>

<programlisting>from rpc.datagen import DataGenerator
from rpc.datagen import CausalModelGenerator
from rpc.dataretrieval import Database
from rpc.model.util import ModelSupport
from rpc.model import RelationalPC
from rpc.model.scoring import ModelScoring
</programlisting>

<?pagebreak?>
<para>The database name and path to the schema file are passed in on the
command line. The script loads the Prolog code module and schema file
for the target database.</para>

<programlisting>dbName = ckd.args[0]
schemaName = ckd.args[1]

ckd.loadRPC()
ckd.loadSchema(schemaName)
</programlisting>

<para>Set parameter values.
<blockquote>
<itemizedlist>
<listitem><para><code>hopThreshold</code> determines he number of
  &ldquo;hops&rdquo; from a starting entity or relationship that the
  algorithm can travel when creating units.</para></listitem>
<listitem><para><code>maxParents</code> is used by data generation to
  set a limit on the number of parents a node may have.</para></listitem>
<listitem><para><code>rpcDepth</code> determines the maximum size of the
  conditioning set.</para></listitem>
<listitem><para><code>numDependencies</code> is used by data
  generation to set the number of dependencies randomly created in the
  true model of the generated data.</para></listitem>
<listitem><para><code>sampleSize</code> is provided as a convenience
  for this script; it is used in determining the size of the tables
  for each entity.</para></listitem>
</itemizedlist></blockquote></para>

<programlisting>hopThreshold = 2
maxParents = 2
rpcDepth = 2
numDependencies = 10
sampleSize = 800
</programlisting>

<para>Generate a random (known) causal model structure for use in data
generation.  Instantiate the causal model and remember the true models for
later use (trueModel).  Optionally, write out the true model for visualization.</para>

<programlisting>cg = CausalModelGenerator(numDependencies, hopThreshold, maxParents)
trueModel = cg.getModel()               
#trueModel.getDotFile("trueModel_dep" + str(numDependencies) + ".dot", 1)
</programlisting>

<para>Parameterize the dependencies in the causal model.
We first parameterize the model to specify the average cardinalities
and conditional probability distributions of attributes for related
entities. For example, the code below specifies that there will be an
average of two <token role="entity">b</token> entities linked to each
<token role="entity">a</token> entity.  Attribute values are assigned
randomly within the constraints imposed by the model&rsquo;s structure.</para>

<programlisting>p = cg.parameterize({"ab":2.0, "da":1.0, "bc":2.0})
</programlisting>

<para>Generate data from the known causal model structure and
parameters.  In this code, we specify that the generated data will
include twice as many <token role="entity">b</token> entities and half
as many <token role="entity">c</token> entities as there are
<token role="entity">a</token> and <token role="entity">d</token>
entities.</para>

<programlisting>dg = DataGenerator(dbName)
dg.generate(cg, p, {"a":sampleSize, "b":2*sampleSize, "c":sampleSize/2,
        "d":sampleSize})
dg.close()
</programlisting>

<para>Open the newly generated database and set the
hop threshold.</para>

<programlisting>Database.open(dbName)
ckd.setHopThreshold(hopThreshold)
</programlisting>

<para>Identify potential units in the generated data. Units are
created by combining two &ldquo;paths,&rdquo; each of which
corresponds to a base entity or relationship with the possible addition of
entities and relationships up to two hops (<code>hopThreshold</code>) away
from that base item.
Paths are paired with other paths sharing the
same base entity or relationship to create a unit consisting of an
outcome path and a treatment path.
The algorithm converts the outcome path into a
singleton and combines the rest of the unit structure into
the treatment path.</para>
<para>For example, the pair of paths <token role="entity">[a ab b].y</token> and
<token role="entity">[a da d].w</token> can be combined because they share a common
base item (the entity <token role="entity">a</token>), yielding an
outcome path of <token role="entity">d.w</token> and a treatment path of 
<token role="entity">[d da a ab b].y.</token></para>

<programlisting>allUnits = ckd.getUnits()
uniqueUnits = ckd.getUniqueUnits()
</programlisting>

<para>Initialize model support data structure.</para>

<programlisting>ckd.modelSupport = ModelSupport(allUnits, uniqueUnits, hopThreshold)
</programlisting>

<para>Set the significance level (alpha) and strength of effect.
The significance threshold (alpha) is Bonferroni-adjusted due
to the multiple significance tests run. &rpc; ignores any possible
dependencies with a strength of effect less than that specified.</para>

<programlisting>rpc = RelationalPC(ckd.modelSupport)
rpc.setSignficanceThresholdAdjust(0.01)
rpc.setStrengthOfEffectThreshold(0.1)
</programlisting>

<para>Phase I: Skeleton identification. Optionally, write the learned
(before edge orientation) model to a file for visualization.</para>

<programlisting>rpc.identifySkeleton(rpcDepth)
learnedModel = rpc.getModel()
#learnedModel.getDotFile("learnedModelPhaseI_dep" + str(numDependencies)
        + "_ss" + str(sampleSize) + ".dot", 1)
</programlisting>

<para>Score the model. At this point, the learned model is still
undirected.  Determine how many edges can be trivially
oriented at this point (we need the <code>errorCts</code> to get this value).
<programlisting>errorCts = ModelScoring.getErrorCounts(trueModel, learnedModel)
trivialOrient = list(errorCts)[0]
</programlisting></para>

<para>Phase II: Edge orientation.</para>

<programlisting>rpc.orientEdges()
</programlisting>

<para>Print out the resulting constraints and dependencies. Optionally,
save the learned model (after edge orientation) to a file for visualization.</para>

<programlisting>print "Independence constraints:"
for constraint in rpc.getConstraints():
        print "\t" + constraint

print "Dependencies:"
for dependence in rpc.getDependencies():
        print "\t" + str(dependence)

learnedModel = rpc.getModel()
#learnedModel.getDotFile("learnedModelPhaseII_dep" + str(numDependencies)
        + "_ss" + str(sampleSize) + ".dot", 1)
</programlisting>

<para>Score the model.</para>

<programlisting>errorCts = ModelScoring.getErrorCounts(trueModel, learnedModel)

sprecision = ModelScoring.getSPrecision(errorCts)
srecall = ModelScoring.getSRecall(errorCts)
cprecision = ModelScoring.getCPrecision(errorCts)
crecall = ModelScoring.getCRecall(errorCts)

ruleFreqs = ModelScoring.getEdgeRuleFrequencies()
cd = ruleFreqs.get("CD") if ruleFreqs.containsKey("CD") else 0
rem = ruleFreqs.get("REM") if ruleFreqs.containsKey("REM") else 0
knc = ruleFreqs.get("KNC") if ruleFreqs.containsKey("KNC") else 0
ca = ruleFreqs.get("CA") if ruleFreqs.containsKey("CA") else 0

oracleCRecall = ModelScoring.getOracleCRecall(ckd.modelSupport, trueModel)
</programlisting>

<para>Print evaluation metrics.
The &ldquo;S&rdquo; values refer to the undirected skeleton, and
the &ldquo;C&rdquo; values refer to the compelled (directed) model.
The edge rule frequencies tell us how many times each edge-orientation
rule was used.  &rpcfull; uses the following edge-orientation rules:
<blockquote>
<variablelist spacing="compact">
<varlistentry>
  <term><code>cd</code></term>
  <listitem><para>collider detection</para></listitem>
</varlistentry>
<varlistentry>
  <term><code>rem</code></term>
  <listitem><para>restricted existence models</para></listitem>
</varlistentry>
<varlistentry>
  <term><code>knc</code></term>
  <listitem><para>known non-collider</para></listitem>
</varlistentry>
<varlistentry>
  <term><code>ca</code></term>
  <listitem><para>cycle avoidance</para></listitem>
</varlistentry>
</variablelist>
</blockquote>
<code>OracleCRecall</code> tells us how many of the edges &rpc; would orient
correctly if given the true undirected skeleton.
</para>

<programlisting>print "SPrecision:", sprecision
print "SRecall:", srecall
print "CPrecision:", cprecision
print "CRecall:", crecall
print "Triv:", trivialOrient
print "Edge Rule Frequencies:", "cd:", cd, "rem:", rem, "knc:", knc, "ca:", ca
print "Oracle CRecall:", oracleCRecall
</programlisting>

<para>Close the database connection.</para>

<programlisting>Database.close()
</programlisting>

<section>
<title>Running runRPC.py</title>

<para>To execute the <filename>runRPC.py</filename> script,
change to the root of your local &rpc; installation and type
the following command:</para>
<synopsis>&prompt; cd <userinput>&rpchome;</userinput>
&prompt; <userinput>bin/script.sh example/scripts/runRPC.py testdb example/schemas/datagen-schema.pl</userinput>
</synopsis>

</section>

<section>
<title>Interpreting &rpc; results</title>

<para>The output from running <filename>runRPC.py</filename> contains
two important sections:
<itemizedlist spacing="compact">
  <listitem><para>a list of independence constraints that describe all
    possible treatment and outcome pairs</para></listitem>
  <listitem><para>a list of dependencies identifying the units for
    which the algorithm could not conditionally separate the treatment
    and outcome</para></listitem>
</itemizedlist>
</para>

<para>For example, the independence constraint
<blockquote>
<synopsis>Path [c, bc, b], AttrVar: b.y _||_ Path: [c], AttrVar: c.z | []</synopsis>
</blockquote>
indicates that the outcome variable (the <token role="attr">z</token>
attribute on the <token role="entity">c</token> entity) is conditionally
independent of the treatment (the <token role="attr">y</token>
attribute on the <token role="entity">b</token> entity related to
<token role="entity">c</token> through the
<token role="edge">bc</token> relationship), given nothing (the final
&ldquo;<code>[]</code>&rdquo; in the statement).</para>

<para>The dependency
<blockquote>
<synopsis>(Base: b, Treatment Path &lt;Path: [b, ab, a], AttrVar: a.x&gt;,
          Outcome Path &lt;Path: [b], AttrVar: b.y&gt;)</synopsis>
</blockquote>
Indicates that &rpc; could not conditionally separate the treatment
variable (the <token role="attr">x</token> attribute on the 
<token role="entity">a</token> entity in the unit <code>[b, ab, a]</code>)
from the outcome variable (the <token role="attr">y</token> attribute
on the <token role="entity">b</token> entity).</para>

</section>


</section>

<!-- ============================================================== -->
<!--                   RUNNING RPC ON EXISTING DATA                 -->
<!-- ============================================================== -->

<section>
<title>Running &rpc; on Existing Data</title>

<para>The <filename>runRPCUsingDatabase.py</filename> script illustrates how to run
&rpc; on existing data.</para>

<!-- .............................................................. -->
<!--               Code Example: runRPCUsingDatabse.py              -->
<!-- .............................................................. -->

<!-- <?pagebreak?> -->
<para>Import needed classes.</para>

<programlisting>from rpc.dataretrieval import Database
from rpc.model.util import ModelSupport
from rpc.model import RelationalPC
</programlisting>

<para>Set parameter values.
<blockquote>
<itemizedlist>
<listitem><para><code>rpcDepth</code> determines the maximum size of the
  conditioning set.</para></listitem>
<listitem><para><code>hopThreshold</code> determines he number of
  &ldquo;hops&rdquo; from a starting entity or relationship that the
  algorithm can travel when creating units.</para></listitem>
</itemizedlist>
</blockquote></para>

<programlisting>rpcDepth = 2
hop_threshold = 2
</programlisting>

<para>The database name and path to the schema file are passed in on the
command line. The script loads the Prolog code module and schema file
for the target database. Set the hop threshold.</para>

<programlisting>Database.open(ckd.args[0]) 
ckd.loadRPC()
ckd.loadSchema(ckd.args[1]) 

ckd.setHopThreshold(hop_threshold)
</programlisting>

<para>Identify potential units in the database. Combine paths having
the same base entity or relationship to create outcome and treatment
paths.</para>

<programlisting>allUnits = ckd.getUnits()
uniqueUnits = ckd.getUniqueUnits()
</programlisting>


<para>Initialize model support data structure.</para>

<programlisting>ckd.modelSupport = ModelSupport(allUnits, uniqueUnits, ckd.getHopThreshold())
</programlisting>

<para>Set the significance level (alpha) and strength of effect.
</para>

<programlisting>rpc = RelationalPC(ckd.modelSupport)
rpc.setSignficanceThresholdAdjust(0.01)
rpc.setStrengthOfEffectThreshold(0.1)
</programlisting>

<para>Phase I: Skeleton identification. Optionally, write the learned
(before edge orientation) model to a file for visualization.</para>

<programlisting>rpc.identifySkeleton(rpcDepth)
learnedModel = rpc.getModel()
#learnedModel.getDotFile("LearnedModelPhaseI.dot", 1)
</programlisting>

<para>Phase II: Skeleton identification. Optionally, write the learned
(after edge orientation) model to a file for visualization.</para>

<programlisting>rpc.orientEdges()
learnedModel = rpc.getModel()
#learnedModel.getDotFile("LearnedModelPhaseII.dot", 1)
</programlisting>

<para>Print out the resulting constraints and dependencies.</para>

<programlisting>print "Independence constraints:"
for constraint in rpc.getConstraints():
        print "\t" + constraint

print "Dependencies:"
for dependence in rpc.getDependencies():
        print "\t" + str(dependence)
</programlisting>

<para>Close the database connection.</para>

<programlisting>Database.close()
</programlisting>

<!-- .............................................................. -->
<!--                  Running RunRPCUSingDatabse.py                 -->
<!-- .............................................................. -->

<section>
<title>Running runRPCUsingDatabase.py</title>

<para>To execute the <filename>runRPCUsingDatabase.py</filename> script,
change to the root of your local &rpc; installation and type
the following command:</para>
<synopsis>&prompt; cd <userinput>&rpchome;</userinput>
&prompt; <userinput>bin/script.sh example/scripts/runRPC.py <replaceable>db-name</replaceable> schema-file</userinput>
</synopsis>
<para>
where
<replaceable>db-name</replaceable> is the name of the PostgreSQL
database being served and <replaceable>schema-file</replaceable> is
the path to the file defining the schema for this database..</para>

</section>


</section>

</chapter>

<!--
  Local Variables:
  mode: sgml
  sgml-set-face: t
  sgml-indent-step: nil
  sgml-always-quote-attributes: t
  sgml-parent-document: ("RPC_Main.xml" "book" "chapter")
  sgml-default-dtd-file:"../DocBook.ced"
  End:
-->
