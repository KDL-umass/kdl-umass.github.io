<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <!-- Part of the KDL Relational PC package (see LICENSE for
      copyright and license information). -->
      <title>Running RPC on Generated Data</title>
      <link rel="stylesheet" href="kdldoc.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
      <link rel="start" href="index.html" title="Relational PC User's Guide">
      <link rel="up" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Running Relational PC">
      <link rel="prev" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Running Relational PC">
      <link rel="next" href="ch02s02s02.html" title="Interpreting RPC results">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:exsl="http://exslt.org/common" class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">Chapter&nbsp;2.&nbsp;Running Relational PC</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s02s02.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div class="section" lang="en">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title" style="clear: both"><a name="datagenrun"></a>Running RPC on Generated Data
                  </h2>
               </div>
            </div>
         </div>
         <p>The <code class="filename">runRPC.py</code> script illustrates how to run
            RPC on generated data. The generated data used in this example is
            described by the schema file 
            <code class="filename">$RPC_HOME/example/schemas/datagen-schema.pl</code>.
            This schema file is discussed in detail in
            <a class="xref" href="ch03.html" title="Chapter&nbsp;3.&nbsp;Data for Relational PC">Chapter&nbsp;3</a>, later in this document.
         </p>
         <p>Import needed classes.</p><pre class="programlisting">from rpc.datagen import DataGenerator
from rpc.datagen import CausalModelGenerator
from rpc.dataretrieval import Database
from rpc.model.util import ModelSupport
from rpc.model import RelationalPC
from rpc.model.scoring import ModelScoring
</pre><p>The database name and path to the schema file are passed in on the
            command line. The script loads the Prolog code module and schema file
            for the target database.
         </p><pre class="programlisting">dbName = ckd.args[0]
schemaName = ckd.args[1]

ckd.loadRPC()
ckd.loadSchema(schemaName)
</pre><p>Set parameter values.
            
         </p>
         <div class="blockquote">
            <blockquote class="blockquote">
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p><code class="code">hopThreshold</code> determines he number of
                             &#8220;hops&#8221; from a starting entity or relationship that the
                             algorithm can travel when creating units.
                        </p>
                     </li>
                     <li>
                        <p><code class="code">maxParents</code> is used by data generation to
                             set a limit on the number of parents a node may have.
                        </p>
                     </li>
                     <li>
                        <p><code class="code">rpcDepth</code> determines the maximum size of the
                             conditioning set.
                        </p>
                     </li>
                     <li>
                        <p><code class="code">numDependencies</code> is used by data
                             generation to set the number of dependencies randomly created in the
                             true model of the generated data.
                        </p>
                     </li>
                     <li>
                        <p><code class="code">sampleSize</code> is provided as a convenience
                             for this script; it is used in determining the size of the tables
                             for each entity.
                        </p>
                     </li>
                  </ul>
               </div>
            </blockquote>
         </div><pre class="programlisting">hopThreshold = 2
maxParents = 2
rpcDepth = 2
numDependencies = 10
sampleSize = 800
</pre><p>Generate a random (known) causal model structure for use in data
            generation.  Instantiate the causal model and remember the true models for
            later use (trueModel).  Optionally, write out the true model for visualization.
         </p><pre class="programlisting">cg = CausalModelGenerator(numDependencies, hopThreshold, maxParents)
trueModel = cg.getModel()               
#trueModel.getDotFile("trueModel_dep" + str(numDependencies) + ".dot", 1)
</pre><p>Parameterize the dependencies in the causal model.
            We first parameterize the model to specify the average cardinalities
            and conditional probability distributions of attributes for related
            entities. For example, the code below specifies that there will be an
            average of two <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">b</span> entities linked to each
            <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">a</span> entity.  Attribute values are assigned
            randomly within the constraints imposed by the model&#8217;s structure.
         </p><pre class="programlisting">p = cg.parameterize({"ab":2.0, "da":1.0, "bc":2.0})
</pre><p>Generate data from the known causal model structure and
            parameters.  In this code, we specify that the generated data will
            include twice as many <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">b</span> entities and half
            as many <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">c</span> entities as there are
            <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">a</span> and <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">d</span>
            entities.
         </p><pre class="programlisting">dg = DataGenerator(dbName)
dg.generate(cg, p, {"a":sampleSize, "b":2*sampleSize, "c":sampleSize/2,
        "d":sampleSize})
dg.close()
</pre><p>Open the newly generated database and set the
            hop threshold.
         </p><pre class="programlisting">Database.open(dbName)
ckd.setHopThreshold(hopThreshold)
</pre><p>Identify potential units in the generated data. Units are
            created by combining two &#8220;paths,&#8221; each of which
            corresponds to a base entity or relationship with the possible addition of
            entities and relationships up to two hops (<code class="code">hopThreshold</code>) away
            from that base item.
            Paths are paired with other paths sharing the
            same base entity or relationship to create a unit consisting of an
            outcome path and a treatment path.
            The algorithm converts the outcome path into a
            singleton and combines the rest of the unit structure into
            the treatment path.
         </p>
         <p>For example, the pair of paths <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">[a ab b].y</span> and
            <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">[a da d].w</span> can be combined because they share a common
            base item (the entity <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">a</span>), yielding an
            outcome path of <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">d.w</span> and a treatment path of 
            <span xmlns:exsl="http://exslt.org/common" class="token" style="font-family: sans-serif">[d da a ab b].y.</span></p><pre class="programlisting">allUnits = ckd.getUnits()
uniqueUnits = ckd.getUniqueUnits()
</pre><p>Initialize model support data structure.</p><pre class="programlisting">ckd.modelSupport = ModelSupport(allUnits, uniqueUnits, hopThreshold)
</pre><p>Set the significance level (alpha) and strength of effect.
            The significance threshold (alpha) is Bonferroni-adjusted due
            to the multiple significance tests run. RPC ignores any possible
            dependencies with a strength of effect less than that specified.
         </p><pre class="programlisting">rpc = RelationalPC(ckd.modelSupport)
rpc.setSignficanceThresholdAdjust(0.01)
rpc.setStrengthOfEffectThreshold(0.1)
</pre><p>Phase I: Skeleton identification. Optionally, write the learned
            (before edge orientation) model to a file for visualization.
         </p><pre class="programlisting">rpc.identifySkeleton(rpcDepth)
learnedModel = rpc.getModel()
#learnedModel.getDotFile("learnedModelPhaseI_dep" + str(numDependencies)
        + "_ss" + str(sampleSize) + ".dot", 1)
</pre><p>Score the model. At this point, the learned model is still
            undirected.  Determine how many edges can be trivially
            oriented at this point (we need the <code class="code">errorCts</code> to get this value).
            
         </p><pre class="programlisting">errorCts = ModelScoring.getErrorCounts(trueModel, learnedModel)
trivialOrient = list(errorCts)[0]
</pre><p>Phase II: Edge orientation.</p><pre class="programlisting">rpc.orientEdges()
</pre><p>Print out the resulting constraints and dependencies. Optionally,
            save the learned model (after edge orientation) to a file for visualization.
         </p><pre class="programlisting">print "Independence constraints:"
for constraint in rpc.getConstraints():
        print "\t" + constraint

print "Dependencies:"
for dependence in rpc.getDependencies():
        print "\t" + str(dependence)

learnedModel = rpc.getModel()
#learnedModel.getDotFile("learnedModelPhaseII_dep" + str(numDependencies)
        + "_ss" + str(sampleSize) + ".dot", 1)
</pre><p>Score the model.</p><pre class="programlisting">errorCts = ModelScoring.getErrorCounts(trueModel, learnedModel)

sprecision = ModelScoring.getSPrecision(errorCts)
srecall = ModelScoring.getSRecall(errorCts)
cprecision = ModelScoring.getCPrecision(errorCts)
crecall = ModelScoring.getCRecall(errorCts)

ruleFreqs = ModelScoring.getEdgeRuleFrequencies()
cd = ruleFreqs.get("CD") if ruleFreqs.containsKey("CD") else 0
rem = ruleFreqs.get("REM") if ruleFreqs.containsKey("REM") else 0
knc = ruleFreqs.get("KNC") if ruleFreqs.containsKey("KNC") else 0
ca = ruleFreqs.get("CA") if ruleFreqs.containsKey("CA") else 0

oracleCRecall = ModelScoring.getOracleCRecall(ckd.modelSupport, trueModel)
</pre><p>Print evaluation metrics.
            The &#8220;S&#8221; values refer to the undirected skeleton, and
            the &#8220;C&#8221; values refer to the compelled (directed) model.
            The edge rule frequencies tell us how many times each edge-orientation
            rule was used.  Relational PC uses the following edge-orientation rules:
            
         </p>
         <div class="blockquote">
            <blockquote class="blockquote">
               <div class="variablelist">
                  <table border="0">
                     <col align="left" valign="top">
                     <tbody>
                        <tr>
                           <td>
                              <p><span class="term"><code class="code">cd</code></span></p>
                           </td>
                           <td>
                              <p>collider detection</p>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <p><span class="term"><code class="code">rem</code></span></p>
                           </td>
                           <td>
                              <p>restricted existence models</p>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <p><span class="term"><code class="code">knc</code></span></p>
                           </td>
                           <td>
                              <p>known non-collider</p>
                           </td>
                        </tr>
                        <tr>
                           <td>
                              <p><span class="term"><code class="code">ca</code></span></p>
                           </td>
                           <td>
                              <p>cycle avoidance</p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </blockquote>
         </div>
         <p>
            <code class="code">OracleCRecall</code> tells us how many of the edges RPC would orient
            correctly if given the true undirected skeleton.
            
         </p><pre class="programlisting">print "SPrecision:", sprecision
print "SRecall:", srecall
print "CPrecision:", cprecision
print "CRecall:", crecall
print "Triv:", trivialOrient
print "Edge Rule Frequencies:", "cd:", cd, "rem:", rem, "knc:", knc, "ca:", ca
print "Oracle CRecall:", oracleCRecall
</pre><p>Close the database connection.</p><pre class="programlisting">Database.close()
</pre><div class="section" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="d0e814"></a>Running runRPC.py
                     </h3>
                  </div>
               </div>
            </div>
            <p>To execute the <code class="filename">runRPC.py</code> script,
               change to the root of your local RPC installation and type
               the following command:
            </p><pre class="synopsis">&gt; cd <strong class="userinput"><code>$RPC_HOME</code></strong>
&gt; <strong class="userinput"><code>bin/script.sh example/scripts/runRPC.py testdb example/schemas/datagen-schema.pl</code></strong>
</pre></div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="ch02.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s02s02.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;2.&nbsp;Running Relational PC&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Interpreting RPC results</td>
            </tr>
         </table>
      </div>
   </body>
</html>